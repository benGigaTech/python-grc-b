diff --git a/README.md b/README.md
index 294a134..4925bf3 100644
--- a/README.md
+++ b/README.md
@@ -57,6 +57,26 @@ The CMMC Compliance Tracker helps organizations manage their cybersecurity contr
 
 The database will be automatically initialized with sample data on first startup. No manual initialization is required.
 
+### Database Migrations
+
+When schema changes are required, SQL migration files are provided in the `db` directory. To apply migrations:
+
+1. **Using the migration script**:
+   ```
+   # Apply all migrations
+   python apply_migration.py
+   
+   # Apply a specific migration
+   python apply_migration.py db/evidence_migration.sql
+   ```
+
+2. **Within Docker**:
+   ```
+   docker compose exec web python apply_migration.py
+   ```
+
+Migration files are named descriptively (e.g., `evidence_migration.sql`) to indicate their purpose.
+
 ### Default Credentials
 
 - **Admin User**:
diff --git a/add_sample_evidence.py b/add_sample_evidence.py
new file mode 100644
index 0000000..7aeab41
--- /dev/null
+++ b/add_sample_evidence.py
@@ -0,0 +1,159 @@
+#!/usr/bin/env python
+"""
+add_sample_evidence.py - Add sample evidence records to the database for testing
+
+Run this script after applying migrations to populate the evidence table with test data.
+"""
+
+import os
+import logging
+import psycopg2
+from datetime import datetime, timedelta
+import random
+
+# Set up logging
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(asctime)s - %(levelname)s - %(message)s'
+)
+logger = logging.getLogger(__name__)
+
+# Database connection parameters
+DB_HOST = os.environ.get('DB_HOST', 'db')
+DB_PORT = os.environ.get('DB_PORT', '5432')
+DB_NAME = os.environ.get('DB_NAME', 'cmmc_db')
+DB_USER = os.environ.get('DB_USER', 'cmmc_user')
+DB_PASSWORD = os.environ.get('DB_PASSWORD', 'password')
+
+# Sample evidence data
+SAMPLE_EVIDENCE = [
+    {
+        "title": "Access Control Policy",
+        "description": "Organizational policy document detailing access control procedures and requirements",
+        "filetype": "application/pdf",
+        "filesize": 1024 * 1024 * 2,  # 2MB
+        "uploadedby": "admin",
+        "expirationdate": (datetime.now() + timedelta(days=365)).strftime('%Y-%m-%d'),
+        "status": "Current"
+    },
+    {
+        "title": "System Configuration Baseline",
+        "description": "Configuration baseline for all organization systems",
+        "filetype": "application/xlsx",
+        "filesize": 1024 * 512,  # 512KB
+        "uploadedby": "admin",
+        "expirationdate": (datetime.now() + timedelta(days=180)).strftime('%Y-%m-%d'),
+        "status": "Current"
+    },
+    {
+        "title": "Security Assessment Report",
+        "description": "Annual security assessment results and findings",
+        "filetype": "application/pdf",
+        "filesize": 1024 * 1024 * 5,  # 5MB
+        "uploadedby": "user",
+        "expirationdate": (datetime.now() + timedelta(days=90)).strftime('%Y-%m-%d'),
+        "status": "Current"
+    },
+    {
+        "title": "Security Training Completion Records",
+        "description": "Records of employee security awareness training completion",
+        "filetype": "application/pdf",
+        "filesize": 1024 * 768,  # 768KB
+        "uploadedby": "user",
+        "expirationdate": (datetime.now() + timedelta(days=30)).strftime('%Y-%m-%d'),
+        "status": "Expiring Soon"
+    },
+    {
+        "title": "Historical Risk Assessment",
+        "description": "Previous year's risk assessment document",
+        "filetype": "application/pdf",
+        "filesize": 1024 * 1024 * 3,  # 3MB
+        "uploadedby": "admin",
+        "expirationdate": (datetime.now() - timedelta(days=60)).strftime('%Y-%m-%d'),
+        "status": "Expired"
+    }
+]
+
+def add_sample_evidence():
+    """Add sample evidence records to the database"""
+    try:
+        conn = psycopg2.connect(
+            host=DB_HOST,
+            port=DB_PORT,
+            dbname=DB_NAME,
+            user=DB_USER,
+            password=DB_PASSWORD
+        )
+        cursor = conn.cursor()
+        
+        # First, check if the evidence table exists
+        cursor.execute("""
+            SELECT EXISTS (
+                SELECT FROM information_schema.tables 
+                WHERE table_name = 'evidence'
+            );
+        """)
+        table_exists = cursor.fetchone()[0]
+        
+        if not table_exists:
+            logger.error("❌ Evidence table does not exist in the database")
+            logger.error("Please run the migrations first: python apply_migration.py")
+            return
+        
+        # Check if there are any controls to associate evidence with
+        cursor.execute("SELECT controlid FROM controls LIMIT 10")
+        control_ids = cursor.fetchall()
+        
+        if not control_ids:
+            logger.error("❌ No controls found in the database")
+            logger.error("Please run seed_db.py first to populate the controls table")
+            return
+        
+        # Flatten the control_ids list
+        control_ids = [control[0] for control in control_ids]
+        
+        # Get current timestamp for upload dates
+        now = datetime.now().strftime('%Y-%m-%d')
+        
+        # Add sample evidence for each control
+        sample_count = 0
+        for i, evidence in enumerate(SAMPLE_EVIDENCE):
+            # Select a random control ID
+            control_id = random.choice(control_ids)
+            
+            # Generate a filepath
+            filepath = f"/uploads/{control_id}/{now.replace('-', '')}_{evidence['title'].replace(' ', '_')}.{evidence['filetype'].split('/')[-1]}"
+            
+            # Insert the evidence record
+            cursor.execute("""
+                INSERT INTO evidence (
+                    controlid, title, description, filepath, filetype, filesize,
+                    uploadedby, uploaddate, expirationdate, status
+                ) VALUES (
+                    %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
+                )
+            """, (
+                control_id,
+                evidence['title'],
+                evidence['description'],
+                filepath,
+                evidence['filetype'],
+                evidence['filesize'],
+                evidence['uploadedby'],
+                now,
+                evidence['expirationdate'],
+                evidence['status']
+            ))
+            sample_count += 1
+        
+        conn.commit()
+        logger.info(f"✅ Added {sample_count} sample evidence records to the database")
+        
+        cursor.close()
+        conn.close()
+        
+    except Exception as e:
+        logger.error(f"Error adding sample evidence: {e}")
+
+if __name__ == "__main__":
+    add_sample_evidence() 
\ No newline at end of file
diff --git a/apply_migration.py b/apply_migration.py
new file mode 100644
index 0000000..a5c316b
--- /dev/null
+++ b/apply_migration.py
@@ -0,0 +1,148 @@
+#!/usr/bin/env python
+"""
+apply_migration.py - Applies SQL migration scripts to the database
+Run this script to execute SQL migration files
+
+Usage:
+    python apply_migration.py [filename.sql]
+    
+If no filename is provided, all .sql files in the db directory will be executed.
+"""
+
+import os
+import sys
+import time
+import logging
+import psycopg2
+from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
+
+# Set up logging
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(asctime)s - %(levelname)s - %(message)s'
+)
+logger = logging.getLogger(__name__)
+
+# Database connection parameters
+DB_HOST = os.environ.get('DB_HOST', 'db')
+DB_PORT = os.environ.get('DB_PORT', '5432')
+DB_NAME = os.environ.get('DB_NAME', 'cmmc_db')
+DB_USER = os.environ.get('DB_USER', 'cmmc_user')
+DB_PASSWORD = os.environ.get('DB_PASSWORD', 'password')
+
+def get_db_connection():
+    """Connect to the application database"""
+    max_retries = 5
+    retry_delay = 2
+    
+    for attempt in range(max_retries):
+        try:
+            conn = psycopg2.connect(
+                host=DB_HOST,
+                port=DB_PORT,
+                dbname=DB_NAME,
+                user=DB_USER,
+                password=DB_PASSWORD
+            )
+            logger.info("Successfully connected to the database")
+            return conn
+        except psycopg2.OperationalError as e:
+            if attempt < max_retries - 1:
+                logger.warning(f"Database connection failed (attempt {attempt+1}/{max_retries}). Retrying in {retry_delay} seconds...")
+                time.sleep(retry_delay)
+            else:
+                logger.error(f"Failed to connect to the database after {max_retries} attempts: {e}")
+                raise
+
+def apply_migration_file(filepath):
+    """Apply a single SQL migration file to the database"""
+    try:
+        with open(filepath, 'r') as f:
+            sql_script = f.read()
+            
+        migration_name = os.path.basename(filepath)
+        logger.info(f"Applying migration: {migration_name}")
+        
+        conn = get_db_connection()
+        cursor = conn.cursor()
+        
+        # Check if migration has already been applied
+        cursor.execute(
+            "SELECT COUNT(*) FROM migration_history WHERE migration_name = %s",
+            (migration_name,)
+        )
+        
+        # If table doesn't exist yet, psycopg2 will raise an exception
+        try:
+            count = cursor.fetchone()[0]
+            if count > 0:
+                logger.info(f"Migration {migration_name} has already been applied, skipping")
+                cursor.close()
+                conn.close()
+                return
+        except psycopg2.Error:
+            # Migration_history table probably doesn't exist yet
+            logger.info("Migration history table doesn't exist yet, will be created")
+        
+        # Execute the SQL script
+        cursor.execute(sql_script)
+        
+        # Try to record this migration in the tracking table
+        try:
+            cursor.execute(
+                "INSERT INTO migration_history (migration_name, applied_by) VALUES (%s, %s)",
+                (migration_name, os.environ.get('USER', 'system'))
+            )
+        except psycopg2.Error as e:
+            # This might fail if we're running the migration that creates the migration_history table
+            logger.warning(f"Could not record migration in history table: {e}")
+        
+        conn.commit()
+        logger.info(f"Migration applied successfully: {migration_name}")
+        
+        cursor.close()
+        conn.close()
+        
+    except Exception as e:
+        logger.error(f"Error applying migration {os.path.basename(filepath)}: {e}")
+        raise
+
+def main():
+    """Main function to apply migrations"""
+    # Check if a specific migration file was specified
+    if len(sys.argv) > 1:
+        migration_file = sys.argv[1]
+        if os.path.exists(migration_file):
+            apply_migration_file(migration_file)
+        else:
+            logger.error(f"Migration file not found: {migration_file}")
+            sys.exit(1)
+    else:
+        # Apply all SQL files in the db directory
+        db_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'db')
+        if not os.path.exists(db_dir):
+            logger.error(f"Database directory not found: {db_dir}")
+            sys.exit(1)
+            
+        # Apply migration_tracking.sql first if it exists
+        tracking_file = os.path.join(db_dir, 'migration_tracking.sql')
+        if os.path.exists(tracking_file):
+            apply_migration_file(tracking_file)
+        
+        # Then apply all other migration files
+        migration_files = [
+            f for f in os.listdir(db_dir) 
+            if f.endswith('.sql') and f != 'init.sql' and f != 'migration_tracking.sql'
+        ]
+        
+        if not migration_files:
+            logger.info("No migration files found to apply")
+            return
+            
+        for migration_file in sorted(migration_files):
+            apply_migration_file(os.path.join(db_dir, migration_file))
+            
+    logger.info("All migrations completed successfully")
+
+if __name__ == "__main__":
+    main() 
\ No newline at end of file
diff --git a/check_evidence_table.py b/check_evidence_table.py
new file mode 100644
index 0000000..f684133
--- /dev/null
+++ b/check_evidence_table.py
@@ -0,0 +1,85 @@
+#!/usr/bin/env python
+"""
+check_evidence_table.py - Checks if the evidence table exists in the database
+
+Run this script to verify that the evidence migration has been successfully applied.
+"""
+
+import os
+import logging
+import psycopg2
+
+# Set up logging
+logging.basicConfig(
+    level=logging.INFO,
+    format='%(asctime)s - %(levelname)s - %(message)s'
+)
+logger = logging.getLogger(__name__)
+
+# Database connection parameters
+DB_HOST = os.environ.get('DB_HOST', 'db')
+DB_PORT = os.environ.get('DB_PORT', '5432')
+DB_NAME = os.environ.get('DB_NAME', 'cmmc_db')
+DB_USER = os.environ.get('DB_USER', 'cmmc_user')
+DB_PASSWORD = os.environ.get('DB_PASSWORD', 'password')
+
+def check_evidence_table():
+    """Check if the evidence table exists in the database"""
+    try:
+        conn = psycopg2.connect(
+            host=DB_HOST,
+            port=DB_PORT,
+            dbname=DB_NAME,
+            user=DB_USER,
+            password=DB_PASSWORD
+        )
+        cursor = conn.cursor()
+        
+        # Check if the evidence table exists
+        cursor.execute("""
+            SELECT EXISTS (
+                SELECT FROM information_schema.tables 
+                WHERE table_name = 'evidence'
+            );
+        """)
+        table_exists = cursor.fetchone()[0]
+        
+        if table_exists:
+            logger.info("✅ Evidence table exists in the database")
+            
+            # Check the structure of the evidence table
+            cursor.execute("""
+                SELECT column_name, data_type 
+                FROM information_schema.columns 
+                WHERE table_name = 'evidence';
+            """)
+            columns = cursor.fetchall()
+            
+            logger.info("Evidence table structure:")
+            for column in columns:
+                logger.info(f"  - {column[0]}: {column[1]}")
+                
+            # Check if indexes exist
+            cursor.execute("""
+                SELECT indexname 
+                FROM pg_indexes 
+                WHERE tablename = 'evidence';
+            """)
+            indexes = cursor.fetchall()
+            
+            logger.info("Evidence table indexes:")
+            for index in indexes:
+                logger.info(f"  - {index[0]}")
+                
+        else:
+            logger.error("❌ Evidence table does not exist in the database")
+            logger.error("Please run the migrations: python apply_migration.py")
+        
+        cursor.close()
+        conn.close()
+        
+    except Exception as e:
+        logger.error(f"Error checking evidence table: {e}")
+
+if __name__ == "__main__":
+    check_evidence_table() 
\ No newline at end of file
diff --git a/cmmc_tracker/app/__init__.py b/cmmc_tracker/app/__init__.py
index 2b8946b..10a75c4 100644
--- a/cmmc_tracker/app/__init__.py
+++ b/cmmc_tracker/app/__init__.py
@@ -97,6 +97,7 @@ def register_blueprints(app):
     from app.routes.tasks import tasks_bp
     from app.routes.admin import admin_bp
     from app.routes.reports import reports_bp
+    from app.routes.evidence import evidence_bp
     
     # Register blueprints
     app.register_blueprint(auth_bp)
@@ -104,6 +105,7 @@ def register_blueprints(app):
     app.register_blueprint(tasks_bp)
     app.register_blueprint(admin_bp, url_prefix='/admin')
     app.register_blueprint(reports_bp)
+    app.register_blueprint(evidence_bp)
 
 # Create a logger instance
 logger = logging.getLogger(__name__)
\ No newline at end of file
diff --git a/cmmc_tracker/app/models/__init__.py b/cmmc_tracker/app/models/__init__.py
index 5726fcd..d1c3ac3 100644
--- a/cmmc_tracker/app/models/__init__.py
+++ b/cmmc_tracker/app/models/__init__.py
@@ -3,4 +3,5 @@
 from app.models.user import User
 from app.models.control import Control
 from app.models.task import Task
-from app.models.audit import AuditLog
\ No newline at end of file
+from app.models.audit import AuditLog
+from app.models.evidence import Evidence
\ No newline at end of file
diff --git a/cmmc_tracker/app/models/evidence.py b/cmmc_tracker/app/models/evidence.py
new file mode 100644
index 0000000..b9aba65
--- /dev/null
+++ b/cmmc_tracker/app/models/evidence.py
@@ -0,0 +1,298 @@
+"""Evidence model for the CMMC Tracker application."""
+
+import logging
+import os
+from datetime import datetime, date
+from app.services.database import get_by_id, insert, update, delete, execute_query, count
+from app.utils.date import parse_date, format_date, is_date_valid
+
+logger = logging.getLogger(__name__)
+
+class Evidence:
+    """Evidence model class for storing compliance evidence metadata."""
+    
+    def __init__(self, evidence_id, control_id, title, description=None, 
+                 file_path=None, file_type=None, file_size=None, uploaded_by=None, 
+                 upload_date=None, expiration_date=None, status="Current"):
+        self.evidence_id = evidence_id
+        self.control_id = control_id
+        self.title = title
+        self.description = description
+        self.file_path = file_path
+        self.file_type = file_type
+        self.file_size = file_size
+        self.uploaded_by = uploaded_by
+        self.upload_date = upload_date
+        self.expiration_date = expiration_date
+        self.status = status
+        self._control_name = None  # Lazy-loaded
+    
+    @property
+    def control_name(self):
+        """Get the associated control name (lazy-loaded)."""
+        if self._control_name is None:
+            query = "SELECT controlname FROM controls WHERE controlid = %s"
+            result = execute_query(query, (self.control_id,), fetch_one=True)
+            self._control_name = result['controlname'] if result else None
+        return self._control_name
+    
+    @property
+    def is_expired(self):
+        """Check if the evidence has expired."""
+        if not self.expiration_date:
+            return False
+        
+        try:
+            expiration = parse_date(self.expiration_date)
+            return expiration < date.today()
+        except ValueError:
+            logger.error(f"Invalid expiration date format for evidence {self.evidence_id}")
+            return False
+    
+    @property
+    def filename(self):
+        """Extract just the filename from the file path."""
+        if not self.file_path:
+            return None
+        return os.path.basename(self.file_path)
+    
+    @classmethod
+    def get_by_id(cls, evidence_id):
+        """
+        Get evidence by ID.
+        
+        Args:
+            evidence_id: The evidence ID
+            
+        Returns:
+            Evidence: An Evidence object or None if not found
+        """
+        evidence_data = get_by_id('evidence', 'evidenceid', evidence_id)
+        if evidence_data:
+            return cls(
+                evidence_data['evidenceid'],
+                evidence_data['controlid'],
+                evidence_data['title'],
+                evidence_data['description'],
+                evidence_data['filepath'],
+                evidence_data['filetype'],
+                evidence_data['filesize'],
+                evidence_data['uploadedby'],
+                evidence_data['uploaddate'],
+                evidence_data['expirationdate'],
+                evidence_data['status']
+            )
+        return None
+    
+    @classmethod
+    def get_by_control(cls, control_id, sort_by='uploaddate', sort_order='desc', limit=None, offset=None):
+        """
+        Get evidence for a specific control.
+        
+        Args:
+            control_id: The control ID
+            sort_by: Column to sort by
+            sort_order: 'asc' or 'desc'
+            limit: Maximum number of records to return
+            offset: Number of records to skip
+            
+        Returns:
+            list: A list of Evidence objects
+        """
+        query = f"""
+            SELECT * FROM evidence
+            WHERE controlid = %s
+            ORDER BY {sort_by} {sort_order.upper()}
+            {"LIMIT %s" if limit else ""}
+            {"OFFSET %s" if offset else ""}
+        """
+        
+        params = [control_id]
+        if limit:
+            params.append(limit)
+        if offset:
+            params.append(offset)
+            
+        evidence_data_list = execute_query(query, tuple(params), fetch_all=True)
+        
+        return [
+            cls(
+                data['evidenceid'],
+                data['controlid'],
+                data['title'],
+                data['description'],
+                data['filepath'],
+                data['filetype'],
+                data['filesize'],
+                data['uploadedby'],
+                data['uploaddate'],
+                data['expirationdate'],
+                data['status']
+            ) for data in evidence_data_list
+        ]
+    
+    @classmethod
+    def count_by_control(cls, control_id):
+        """
+        Count evidence for a specific control.
+        
+        Args:
+            control_id: The control ID
+            
+        Returns:
+            int: The number of evidence items
+        """
+        return count('evidence', 'controlid = %s', (control_id,))
+    
+    @classmethod
+    def get_expired(cls):
+        """
+        Get all expired evidence.
+        
+        Returns:
+            list: A list of expired Evidence objects
+        """
+        today = date.today().isoformat()
+        query = """
+            SELECT * FROM evidence 
+            WHERE expirationdate IS NOT NULL 
+            AND expirationdate != '' 
+            AND expirationdate < %s
+            ORDER BY expirationdate
+        """
+        evidence_data_list = execute_query(query, (today,), fetch_all=True)
+        
+        return [
+            cls(
+                data['evidenceid'],
+                data['controlid'],
+                data['title'],
+                data['description'],
+                data['filepath'],
+                data['filetype'],
+                data['filesize'],
+                data['uploadedby'],
+                data['uploaddate'],
+                data['expirationdate'],
+                data['status']
+            ) for data in evidence_data_list
+        ]
+    
+    @classmethod
+    def create(cls, control_id, title, description, file_path, file_type, file_size, 
+               uploaded_by, expiration_date=None):
+        """
+        Create a new evidence record.
+        
+        Args:
+            control_id: The control ID
+            title: The evidence title
+            description: The evidence description
+            file_path: Path to the stored file
+            file_type: The file MIME type
+            file_size: Size of the file in bytes
+            uploaded_by: Username of the uploader
+            expiration_date: Optional expiration date
+            
+        Returns:
+            Evidence: The created Evidence object or None if creation failed
+        """
+        try:
+            # Format date consistently
+            upload_date = format_date(date.today().isoformat())
+            formatted_expiration = format_date(expiration_date) if expiration_date else None
+            
+            evidence_data = insert('evidence', {
+                'controlid': control_id,
+                'title': title,
+                'description': description,
+                'filepath': file_path,
+                'filetype': file_type,
+                'filesize': file_size,
+                'uploadedby': uploaded_by,
+                'uploaddate': upload_date,
+                'expirationdate': formatted_expiration,
+                'status': 'Current'
+            })
+            
+            if evidence_data:
+                return cls(
+                    evidence_data['evidenceid'],
+                    evidence_data['controlid'],
+                    evidence_data['title'],
+                    evidence_data['description'],
+                    evidence_data['filepath'],
+                    evidence_data['filetype'],
+                    evidence_data['filesize'],
+                    evidence_data['uploadedby'],
+                    evidence_data['uploaddate'],
+                    evidence_data['expirationdate'],
+                    evidence_data['status']
+                )
+            return None
+        except Exception as e:
+            logger.error(f"Error creating evidence: {e}")
+            return None
+    
+    def update(self):
+        """
+        Update evidence in the database.
+        
+        Returns:
+            bool: True if successful, False otherwise
+        """
+        try:
+            update('evidence', 'evidenceid', self.evidence_id, {
+                'controlid': self.control_id,
+                'title': self.title,
+                'description': self.description,
+                'filepath': self.file_path,
+                'filetype': self.file_type,
+                'filesize': self.file_size,
+                'uploadedby': self.uploaded_by,
+                'uploaddate': self.upload_date,
+                'expirationdate': self.expiration_date,
+                'status': self.status
+            })
+            return True
+        except Exception as e:
+            logger.error(f"Error updating evidence: {e}")
+            return False
+    
+    def delete(self):
+        """
+        Delete evidence from the database.
+        
+        Returns:
+            bool: True if successful, False otherwise
+        """
+        try:
+            delete('evidence', 'evidenceid', self.evidence_id)
+            return True
+        except Exception as e:
+            logger.error(f"Error deleting evidence: {e}")
+            return False
+    
+    def to_dict(self):
+        """
+        Convert the Evidence object to a dictionary for templates.
+        
+        Returns:
+            dict: A dictionary representation of the evidence
+        """
+        return {
+            'evidenceid': self.evidence_id,
+            'controlid': self.control_id,
+            'title': self.title,
+            'description': self.description,
+            'filepath': self.file_path,
+            'filetype': self.file_type,
+            'filesize': self.file_size,
+            'uploadedby': self.uploaded_by,
+            'uploaddate': self.upload_date,
+            'expirationdate': self.expiration_date,
+            'status': self.status,
+            'filename': self.filename,
+            'is_expired': self.is_expired,
+            'control_name': self.control_name
+        } 
\ No newline at end of file
diff --git a/cmmc_tracker/app/routes/evidence.py b/cmmc_tracker/app/routes/evidence.py
new file mode 100644
index 0000000..9202b27
--- /dev/null
+++ b/cmmc_tracker/app/routes/evidence.py
@@ -0,0 +1,302 @@
+"""Evidence management routes for the CMMC Tracker application."""
+
+import os
+import logging
+from flask import Blueprint, render_template, redirect, url_for, request, flash, send_file, current_app
+from flask_login import login_required, current_user
+from werkzeug.utils import secure_filename
+from app.models.evidence import Evidence
+from app.models.control import Control
+from app.services.audit import add_audit_log
+from app.services.storage import save_evidence_file, get_evidence_file_path, delete_evidence_file
+from app.utils.date import is_date_valid, format_date
+import math
+
+logger = logging.getLogger(__name__)
+
+# Create blueprint
+evidence_bp = Blueprint('evidence', __name__)
+
+def allowed_file(filename):
+    """Check if a filename has an allowed extension."""
+    return '.' in filename and \
+           filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']
+
+@evidence_bp.route('/control/<control_id>/evidence')
+@login_required
+def list_evidence(control_id):
+    """Display evidence for a specific control."""
+    try:
+        # Verify control exists
+        control = Control.get_by_id(control_id)
+        if not control:
+            flash('Control not found!', 'danger')
+            return redirect(url_for('controls.index'))
+            
+        # Pagination parameters
+        page = request.args.get('page', 1, type=int)
+        items_per_page = 5
+        offset = (page - 1) * items_per_page
+        
+        # Sorting parameters
+        sort_by = request.args.get('sort_by', 'uploaddate')
+        sort_order = request.args.get('sort_order', 'desc')
+        
+        # Validate sort parameters
+        valid_sort_columns = ['title', 'uploaddate', 'expirationdate', 'status']
+        if sort_by not in valid_sort_columns:
+            sort_by = 'uploaddate'
+        
+        if sort_order not in ['asc', 'desc']:
+            sort_order = 'desc'
+        
+        # Get evidence for this control with pagination
+        evidence_list = Evidence.get_by_control(
+            control_id,
+            sort_by=sort_by,
+            sort_order=sort_order,
+            limit=items_per_page,
+            offset=offset
+        )
+        
+        # Convert to dictionaries for the template
+        evidence_dicts = [evidence.to_dict() for evidence in evidence_list]
+        
+        # Get total count for pagination
+        total_count = Evidence.count_by_control(control_id)
+        total_pages = math.ceil(total_count / items_per_page) if total_count > 0 else 1
+        
+        return render_template(
+            'evidence_list.html',
+            control=control.to_dict(),
+            evidence_list=evidence_dicts,
+            page=page,
+            total_pages=total_pages,
+            sort_by=sort_by,
+            sort_order=sort_order,
+            total_count=total_count
+        )
+        
+    except Exception as e:
+        logger.error(f"Error listing evidence for control {control_id}: {e}")
+        flash('An error occurred while retrieving evidence.', 'danger')
+        return redirect(url_for('controls.control_detail', control_id=control_id))
+
+@evidence_bp.route('/control/<control_id>/evidence/add', methods=['GET', 'POST'])
+@login_required
+def add_evidence(control_id):
+    """Add new evidence for a control."""
+    try:
+        # Verify control exists
+        control = Control.get_by_id(control_id)
+        if not control:
+            flash('Control not found!', 'danger')
+            return redirect(url_for('controls.index'))
+            
+        if request.method == 'POST':
+            title = request.form['title']
+            description = request.form['description']
+            expiration_date = request.form.get('expiration_date', '')
+            
+            # Validate inputs
+            if not title:
+                flash('Evidence title is required.', 'danger')
+                return render_template('add_evidence.html', control=control.to_dict())
+                
+            # Validate expiration date if provided
+            if expiration_date and not is_date_valid(expiration_date):
+                flash('Invalid expiration date format. Please use YYYY-MM-DD.', 'danger')
+                return render_template('add_evidence.html', control=control.to_dict())
+            
+            # Check if file was uploaded
+            if 'evidence_file' not in request.files:
+                flash('No file selected.', 'danger')
+                return render_template('add_evidence.html', control=control.to_dict())
+                
+            file = request.files['evidence_file']
+            if file.filename == '':
+                flash('No file selected.', 'danger')
+                return render_template('add_evidence.html', control=control.to_dict())
+                
+            if not allowed_file(file.filename):
+                flash(f'File type not allowed. Allowed types: {", ".join(current_app.config["ALLOWED_EXTENSIONS"])}', 'danger')
+                return render_template('add_evidence.html', control=control.to_dict())
+            
+            # Save the file
+            file_path, file_type, file_size = save_evidence_file(file, control_id)
+            if not file_path:
+                flash('Failed to save evidence file.', 'danger')
+                return render_template('add_evidence.html', control=control.to_dict())
+            
+            # Create evidence record
+            evidence = Evidence.create(
+                control_id,
+                title,
+                description,
+                file_path,
+                file_type,
+                file_size,
+                current_user.username,
+                expiration_date
+            )
+            
+            if evidence:
+                # Log the action
+                add_audit_log(
+                    current_user.username,
+                    'Create Evidence',
+                    'Evidence',
+                    evidence.evidence_id,
+                    f"Added evidence '{title}' for control {control_id}"
+                )
+                
+                flash('Evidence added successfully!', 'success')
+                return redirect(url_for('evidence.list_evidence', control_id=control_id))
+            else:
+                flash('Failed to create evidence record.', 'danger')
+                
+        return render_template('add_evidence.html', control=control.to_dict())
+        
+    except Exception as e:
+        logger.error(f"Error adding evidence for control {control_id}: {e}")
+        flash('An error occurred while adding evidence.', 'danger')
+        return redirect(url_for('evidence.list_evidence', control_id=control_id))
+
+@evidence_bp.route('/evidence/<evidence_id>/download')
+@login_required
+def download_evidence(evidence_id):
+    """Download evidence file."""
+    try:
+        evidence = Evidence.get_by_id(evidence_id)
+        if not evidence:
+            flash('Evidence not found!', 'danger')
+            return redirect(url_for('controls.index'))
+            
+        # Get the file path
+        file_path = get_evidence_file_path(evidence.file_path)
+        if not file_path:
+            flash('Evidence file not found.', 'danger')
+            return redirect(url_for('evidence.list_evidence', control_id=evidence.control_id))
+            
+        # Log the download
+        add_audit_log(
+            current_user.username,
+            'Download Evidence',
+            'Evidence',
+            evidence_id,
+            f"Downloaded evidence '{evidence.title}'"
+        )
+        
+        # Determine the appropriate MIME type for the file
+        mime_type = evidence.file_type
+        
+        # Return the file as an attachment
+        return send_file(
+            file_path,
+            as_attachment=True,
+            download_name=evidence.filename,
+            mimetype=mime_type
+        )
+        
+    except Exception as e:
+        logger.error(f"Error downloading evidence {evidence_id}: {e}")
+        flash('An error occurred while downloading the evidence file.', 'danger')
+        return redirect(url_for('controls.index'))
+
+@evidence_bp.route('/evidence/<evidence_id>/delete', methods=['POST'])
+@login_required
+def delete_evidence(evidence_id):
+    """Delete evidence."""
+    try:
+        evidence = Evidence.get_by_id(evidence_id)
+        if not evidence:
+            flash('Evidence not found!', 'danger')
+            return redirect(url_for('controls.index'))
+            
+        control_id = evidence.control_id
+        title = evidence.title
+        
+        # Delete the file from storage
+        if evidence.file_path:
+            delete_evidence_file(evidence.file_path)
+        
+        # Delete the database record
+        if evidence.delete():
+            # Log the action
+            add_audit_log(
+                current_user.username,
+                'Delete Evidence',
+                'Evidence',
+                evidence_id,
+                f"Deleted evidence '{title}' for control {control_id}"
+            )
+            
+            flash('Evidence deleted successfully!', 'success')
+        else:
+            flash('Failed to delete evidence record.', 'danger')
+            
+        return redirect(url_for('evidence.list_evidence', control_id=control_id))
+        
+    except Exception as e:
+        logger.error(f"Error deleting evidence {evidence_id}: {e}")
+        flash('An error occurred while deleting evidence.', 'danger')
+        return redirect(url_for('controls.index'))
+
+@evidence_bp.route('/evidence/<evidence_id>/update', methods=['GET', 'POST'])
+@login_required
+def update_evidence(evidence_id):
+    """Update evidence metadata."""
+    try:
+        evidence = Evidence.get_by_id(evidence_id)
+        if not evidence:
+            flash('Evidence not found!', 'danger')
+            return redirect(url_for('controls.index'))
+            
+        control_id = evidence.control_id
+        control = Control.get_by_id(control_id)
+        
+        if request.method == 'POST':
+            title = request.form['title']
+            description = request.form['description']
+            expiration_date = request.form.get('expiration_date', '')
+            status = request.form['status']
+            
+            # Validate inputs
+            if not title:
+                flash('Evidence title is required.', 'danger')
+                return render_template('update_evidence.html', evidence=evidence.to_dict(), control=control.to_dict())
+                
+            # Validate expiration date if provided
+            if expiration_date and not is_date_valid(expiration_date):
+                flash('Invalid expiration date format. Please use YYYY-MM-DD.', 'danger')
+                return render_template('update_evidence.html', evidence=evidence.to_dict(), control=control.to_dict())
+            
+            # Update the evidence record
+            evidence.title = title
+            evidence.description = description
+            evidence.expiration_date = format_date(expiration_date) if expiration_date else None
+            evidence.status = status
+            
+            if evidence.update():
+                # Log the action
+                add_audit_log(
+                    current_user.username,
+                    'Update Evidence',
+                    'Evidence',
+                    evidence_id,
+                    f"Updated evidence '{title}' for control {control_id}"
+                )
+                
+                flash('Evidence updated successfully!', 'success')
+                return redirect(url_for('evidence.list_evidence', control_id=control_id))
+            else:
+                flash('Failed to update evidence record.', 'danger')
+                
+        return render_template('update_evidence.html', evidence=evidence.to_dict(), control=control.to_dict())
+        
+    except Exception as e:
+        logger.error(f"Error updating evidence {evidence_id}: {e}")
+        flash('An error occurred while updating evidence.', 'danger')
+        if evidence:
+            return redirect(url_for('evidence.list_evidence', control_id=evidence.control_id))
+        return redirect(url_for('controls.index')) 
\ No newline at end of file
diff --git a/cmmc_tracker/app/services/storage.py b/cmmc_tracker/app/services/storage.py
new file mode 100644
index 0000000..4bdde3d
--- /dev/null
+++ b/cmmc_tracker/app/services/storage.py
@@ -0,0 +1,127 @@
+"""Storage service for the CMMC Tracker application."""
+
+import os
+import logging
+import uuid
+import shutil
+from werkzeug.utils import secure_filename
+from flask import current_app
+
+logger = logging.getLogger(__name__)
+
+def get_evidence_upload_dir():
+    """
+    Get the directory for storing evidence files.
+    
+    Returns:
+        str: Path to the evidence upload directory
+    """
+    upload_dir = os.path.join(current_app.config['UPLOAD_FOLDER'], 'evidence')
+    if not os.path.exists(upload_dir):
+        os.makedirs(upload_dir, exist_ok=True)
+    return upload_dir
+
+def save_evidence_file(file, control_id):
+    """
+    Save an uploaded evidence file to disk.
+    
+    Args:
+        file: The uploaded file object
+        control_id: The ID of the control this evidence is for
+        
+    Returns:
+        tuple: (file_path, file_type, file_size) or (None, None, None) on failure
+    """
+    try:
+        if not file:
+            return None, None, None
+            
+        # Secure the filename and add a UUID to prevent name collisions
+        filename = secure_filename(file.filename)
+        unique_id = uuid.uuid4().hex
+        unique_filename = f"{unique_id}_{filename}"
+        
+        # Create a subdirectory for each control to organize files
+        control_dir = os.path.join(get_evidence_upload_dir(), control_id)
+        if not os.path.exists(control_dir):
+            os.makedirs(control_dir, exist_ok=True)
+        
+        # Determine file path
+        file_path = os.path.join(control_dir, unique_filename)
+        relative_path = os.path.join('evidence', control_id, unique_filename)
+        
+        # Save the file
+        file.save(file_path)
+        
+        # Get file metadata
+        file_size = os.path.getsize(file_path)
+        file_type = file.content_type or 'application/octet-stream'
+        
+        logger.info(f"Saved evidence file: {file_path}")
+        return relative_path, file_type, file_size
+        
+    except Exception as e:
+        logger.error(f"Error saving evidence file: {e}")
+        return None, None, None
+
+def get_evidence_file_path(relative_path):
+    """
+    Get the full file path for a stored evidence file.
+    
+    Args:
+        relative_path: The relative path stored in the database
+        
+    Returns:
+        str: Full file path or None if invalid
+    """
+    if not relative_path:
+        return None
+    
+    # Ensure the path is relative to the upload folder
+    if relative_path.startswith('/'):
+        relative_path = relative_path[1:]
+    
+    # Build the full path
+    full_path = os.path.join(current_app.config['UPLOAD_FOLDER'], relative_path)
+    
+    # Validate the path (security check)
+    upload_folder = current_app.config['UPLOAD_FOLDER']
+    if not os.path.normpath(full_path).startswith(os.path.normpath(upload_folder)):
+        logger.warning(f"Attempted to access file outside upload folder: {relative_path}")
+        return None
+    
+    if not os.path.exists(full_path):
+        logger.warning(f"Evidence file not found: {full_path}")
+        return None
+    
+    return full_path
+
+def delete_evidence_file(relative_path):
+    """
+    Delete an evidence file from disk.
+    
+    Args:
+        relative_path: The relative path stored in the database
+        
+    Returns:
+        bool: True if successful, False otherwise
+    """
+    try:
+        full_path = get_evidence_file_path(relative_path)
+        if full_path and os.path.exists(full_path):
+            os.remove(full_path)
+            logger.info(f"Deleted evidence file: {full_path}")
+            
+            # Clean up empty directories
+            dir_path = os.path.dirname(full_path)
+            if os.path.exists(dir_path) and not os.listdir(dir_path):
+                os.rmdir(dir_path)
+                logger.info(f"Removed empty directory: {dir_path}")
+                
+            return True
+            
+        logger.warning(f"Could not delete evidence file (not found): {relative_path}")
+        return False
+    except Exception as e:
+        logger.error(f"Error deleting evidence file: {e}")
+        return False 
\ No newline at end of file
diff --git a/cmmc_tracker/app/templates/add_evidence.html b/cmmc_tracker/app/templates/add_evidence.html
new file mode 100644
index 0000000..a9667f6
--- /dev/null
+++ b/cmmc_tracker/app/templates/add_evidence.html
@@ -0,0 +1,104 @@
+{% extends "base.html" %}
+
+{% block title %}Add Evidence - {{ control.controlid }}{% endblock %}
+
+{% block content %}
+<h1>Add Evidence for Control: {{ control.controlid }}</h1>
+<p><strong>Control Name:</strong> {{ control.controlname }}</p>
+
+<div class="form-container">
+    <form action="{{ url_for('evidence.add_evidence', control_id=control.controlid) }}" method="post" enctype="multipart/form-data">
+        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
+        
+        <div class="form-group">
+            <label for="title">Title:</label>
+            <input type="text" id="title" name="title" class="form-control" required>
+            <small class="form-text">A descriptive title for this evidence (required)</small>
+        </div>
+        
+        <div class="form-group">
+            <label for="description">Description:</label>
+            <textarea id="description" name="description" class="form-control" rows="3"></textarea>
+            <small class="form-text">Additional details about this evidence</small>
+        </div>
+        
+        <div class="form-group">
+            <label for="evidence_file">Evidence File:</label>
+            <input type="file" id="evidence_file" name="evidence_file" class="form-control-file" required>
+            <small class="form-text">Upload a file as evidence (required)</small>
+            <div class="allowed-types">
+                Allowed file types: PDF, Images (PNG, JPG, GIF), Documents (DOC, DOCX, XLS, XLSX, PPT, PPTX, TXT), CSV
+            </div>
+        </div>
+        
+        <div class="form-group">
+            <label for="expiration_date">Expiration Date:</label>
+            <input type="date" id="expiration_date" name="expiration_date" class="form-control">
+            <small class="form-text">Optional. Set if this evidence has an expiration date</small>
+        </div>
+        
+        <div class="form-buttons">
+            <input type="submit" value="Upload Evidence" class="form-button">
+            <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid) }}" class="button-link">Cancel</a>
+        </div>
+    </form>
+</div>
+
+<style>
+    .form-container {
+        max-width: 700px;
+        margin: 2rem 0;
+        padding: 1.5rem;
+        background-color: #f8fafc;
+        border-radius: 0.5rem;
+        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
+    }
+    
+    .form-group {
+        margin-bottom: 1.5rem;
+    }
+    
+    .form-control {
+        display: block;
+        width: 100%;
+        padding: 0.5rem;
+        font-size: 1rem;
+        border: 1px solid #d1d5db;
+        border-radius: 0.25rem;
+    }
+    
+    .form-control-file {
+        display: block;
+        width: 100%;
+        margin-top: 0.25rem;
+    }
+    
+    label {
+        display: block;
+        margin-bottom: 0.5rem;
+        font-weight: 500;
+    }
+    
+    .form-text {
+        display: block;
+        margin-top: 0.25rem;
+        font-size: 0.875rem;
+        color: #64748b;
+    }
+    
+    .form-buttons {
+        display: flex;
+        gap: 1rem;
+        margin-top: 2rem;
+    }
+    
+    .allowed-types {
+        margin-top: 0.5rem;
+        padding: 0.5rem;
+        background-color: #e0f2fe;
+        border-radius: 0.25rem;
+        font-size: 0.875rem;
+        color: #0369a1;
+    }
+</style>
+{% endblock %} 
\ No newline at end of file
diff --git a/cmmc_tracker/app/templates/control_detail.html b/cmmc_tracker/app/templates/control_detail.html
index f068d78..f5dccfd 100644
--- a/cmmc_tracker/app/templates/control_detail.html
+++ b/cmmc_tracker/app/templates/control_detail.html
@@ -12,6 +12,8 @@
 <p><strong>Next Review Date:</strong> {{ control.nextreviewdate }}</p>
 
 <a href="{{ url_for('controls.edit_control', control_id=control.controlid) }}" class="button-link">Edit Control</a>
+<a href="{{ url_for('tasks.add_task', control_id=control.controlid) }}" class="button-link">Add Task</a>
+<a href="{{ url_for('evidence.list_evidence', control_id=control.controlid) }}" class="button-link">Manage Evidence</a>
 {% if current_user.is_admin %}
     <form action="{{ url_for('controls.delete_control', control_id=control.controlid) }}" method="post" style="display: inline;">
         <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
diff --git a/cmmc_tracker/app/templates/evidence_list.html b/cmmc_tracker/app/templates/evidence_list.html
new file mode 100644
index 0000000..d1d8bd7
--- /dev/null
+++ b/cmmc_tracker/app/templates/evidence_list.html
@@ -0,0 +1,167 @@
+{% extends "base.html" %}
+
+{% block title %}Evidence - {{ control.controlid }}{% endblock %}
+
+{% block content %}
+<h1>Evidence for Control: {{ control.controlid }}</h1>
+<p><strong>Control Name:</strong> {{ control.controlname }}</p>
+
+<div class="action-buttons">
+    <a href="{{ url_for('evidence.add_evidence', control_id=control.controlid) }}" class="button-link">Add Evidence</a>
+    <a href="{{ url_for('controls.control_detail', control_id=control.controlid) }}" class="button-link">Back to Control</a>
+</div>
+
+<h2>Evidence Files
+    <span class="sort-links" style="font-size: smaller;">
+        (Sort By:
+        <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid, sort_by='title', sort_order='asc' if sort_by != 'title' or sort_order == 'desc' else 'desc') }}"
+            class="{% if sort_by == 'title' %}active{% endif %}">Title</a>,
+        <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid, sort_by='uploaddate', sort_order='asc' if sort_by != 'uploaddate' or sort_order == 'desc' else 'desc') }}"
+            class="{% if sort_by == 'uploaddate' %}active{% endif %}">Upload Date</a>,
+        <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid, sort_by='expirationdate', sort_order='asc' if sort_by != 'expirationdate' or sort_order == 'desc' else 'desc') }}"
+            class="{% if sort_by == 'expirationdate' %}active{% endif %}">Expiration Date</a>,
+        <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid, sort_by='status', sort_order='asc' if sort_by != 'status' or sort_order == 'desc' else 'desc') }}"
+            class="{% if sort_by == 'status' %}active{% endif %}">Status</a>)
+    </span>
+</h2>
+
+{% if evidence_list %}
+<div class="table-responsive">
+    <table class="table">
+        <thead>
+            <tr>
+                <th>Title</th>
+                <th>Description</th>
+                <th>File</th>
+                <th>Uploaded By</th>
+                <th>Upload Date</th>
+                <th>Expiration Date</th>
+                <th>Status</th>
+                <th>Actions</th>
+            </tr>
+        </thead>
+        <tbody>
+            {% for evidence in evidence_list %}
+            <tr class="{% if evidence.is_expired %}expired{% endif %}">
+                <td>{{ evidence.title }}</td>
+                <td>{{ evidence.description }}</td>
+                <td>
+                    {% if evidence.filename %}
+                    <a href="{{ url_for('evidence.download_evidence', evidence_id=evidence.evidenceid) }}" class="file-link" title="{{ evidence.filename }}">
+                        {% set filename = evidence.filename %}
+                        {% if filename|length > 20 %}
+                            {{ filename[:10] }}...{{ filename[-7:] }}
+                        {% else %}
+                            {{ filename }}
+                        {% endif %}
+                    </a>
+                    {% else %}
+                    No file
+                    {% endif %}
+                </td>
+                <td>{{ evidence.uploadedby }}</td>
+                <td>{{ evidence.uploaddate }}</td>
+                <td>
+                    {% if evidence.expirationdate %}
+                    {{ evidence.expirationdate }}
+                    {% else %}
+                    No expiration
+                    {% endif %}
+                </td>
+                <td>
+                    {% if evidence.is_expired %}
+                    <span class="badge badge-danger">Expired</span>
+                    {% else %}
+                    <span class="badge badge-success">{{ evidence.status }}</span>
+                    {% endif %}
+                </td>
+                <td>
+                    <div class="action-buttons">
+                        <a href="{{ url_for('evidence.update_evidence', evidence_id=evidence.evidenceid) }}" class="button-link">Edit</a>
+                        <form action="{{ url_for('evidence.delete_evidence', evidence_id=evidence.evidenceid) }}" method="post" style="display: inline;">
+                            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
+                            <button type="submit" class="form-button" onclick="return confirm('Are you sure you want to delete this evidence?');">Delete</button>
+                        </form>
+                    </div>
+                </td>
+            </tr>
+            {% endfor %}
+        </tbody>
+    </table>
+</div>
+
+<!-- Pagination -->
+<div class="pagination">
+    {% if page > 1 %}
+        <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid, page=page-1, sort_by=sort_by, sort_order=sort_order) }}" class="button-link">Previous</a>
+    {% endif %}
+
+    <span>Page {{ page }} of {{ total_pages }}</span>
+
+    {% if page < total_pages %}
+        <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid, page=page+1, sort_by=sort_by, sort_order=sort_order) }}" class="button-link">Next</a>
+    {% endif %}
+</div>
+
+{% else %}
+<p class="no-items">No evidence has been uploaded for this control.</p>
+{% endif %}
+
+<style>
+    .table {
+        width: 100%;
+        border-collapse: collapse;
+        margin-bottom: 1rem;
+    }
+    
+    .table th, .table td {
+        padding: 0.5rem;
+        border: 1px solid #e2e8f0;
+    }
+    
+    .table th {
+        background-color: #f1f5f9;
+        font-weight: 600;
+    }
+    
+    tr.expired {
+        background-color: #fee2e2;
+    }
+    
+    .file-link {
+        color: #3b82f6;
+        text-decoration: none;
+    }
+    
+    .file-link:hover {
+        text-decoration: underline;
+    }
+    
+    .badge {
+        padding: 0.25rem 0.5rem;
+        border-radius: 9999px;
+        font-size: 0.75rem;
+        font-weight: 500;
+    }
+    
+    .badge-success {
+        background-color: #10b981;
+        color: white;
+    }
+    
+    .badge-danger {
+        background-color: #ef4444;
+        color: white;
+    }
+    
+    .no-items {
+        color: #64748b;
+        font-style: italic;
+        margin: 2rem 0;
+    }
+    
+    .action-buttons {
+        margin: 1rem 0;
+    }
+</style>
+{% endblock %} 
\ No newline at end of file
diff --git a/cmmc_tracker/app/templates/update_evidence.html b/cmmc_tracker/app/templates/update_evidence.html
new file mode 100644
index 0000000..dac5c7e
--- /dev/null
+++ b/cmmc_tracker/app/templates/update_evidence.html
@@ -0,0 +1,134 @@
+{% extends "base.html" %}
+
+{% block title %}Update Evidence - {{ evidence.title }}{% endblock %}
+
+{% block content %}
+<h1>Update Evidence</h1>
+<p><strong>Control:</strong> {{ control.controlid }} - {{ control.controlname }}</p>
+<p><strong>Current File:</strong> {{ evidence.filename or "No file" }}</p>
+
+<div class="form-container">
+    <form action="{{ url_for('evidence.update_evidence', evidence_id=evidence.evidenceid) }}" method="post">
+        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
+        
+        <div class="form-group">
+            <label for="title">Title:</label>
+            <input type="text" id="title" name="title" class="form-control" value="{{ evidence.title }}" required>
+            <small class="form-text">A descriptive title for this evidence (required)</small>
+        </div>
+        
+        <div class="form-group">
+            <label for="description">Description:</label>
+            <textarea id="description" name="description" class="form-control" rows="3">{{ evidence.description }}</textarea>
+            <small class="form-text">Additional details about this evidence</small>
+        </div>
+        
+        <div class="form-group">
+            <label for="status">Status:</label>
+            <select id="status" name="status" class="form-control">
+                <option value="Current" {% if evidence.status == 'Current' %}selected{% endif %}>Current</option>
+                <option value="Pending Review" {% if evidence.status == 'Pending Review' %}selected{% endif %}>Pending Review</option>
+                <option value="Expired" {% if evidence.status == 'Expired' or evidence.is_expired %}selected{% endif %}>Expired</option>
+            </select>
+            <small class="form-text">Current status of this evidence</small>
+        </div>
+        
+        <div class="form-group">
+            <label for="expiration_date">Expiration Date:</label>
+            <input type="date" id="expiration_date" name="expiration_date" class="form-control" value="{{ evidence.expirationdate }}">
+            <small class="form-text">Optional. Set if this evidence has an expiration date</small>
+        </div>
+        
+        <div class="file-metadata">
+            <h3>File Information</h3>
+            <p><strong>Uploaded By:</strong> {{ evidence.uploadedby }}</p>
+            <p><strong>Upload Date:</strong> {{ evidence.uploaddate }}</p>
+            <p><strong>File Type:</strong> {{ evidence.filetype or "Unknown" }}</p>
+            <p><strong>File Size:</strong> {{ "%.2f"|format(evidence.filesize / 1024) if evidence.filesize else 0 }} KB</p>
+            
+            <div class="info-note">
+                <span class="icon">ℹ️</span>
+                <span>To replace the file, please delete this evidence and upload a new one.</span>
+            </div>
+        </div>
+        
+        <div class="form-buttons">
+            <input type="submit" value="Update Evidence" class="form-button">
+            <a href="{{ url_for('evidence.list_evidence', control_id=control.controlid) }}" class="button-link">Cancel</a>
+        </div>
+    </form>
+</div>
+
+<style>
+    .form-container {
+        max-width: 700px;
+        margin: 2rem 0;
+        padding: 1.5rem;
+        background-color: #f8fafc;
+        border-radius: 0.5rem;
+        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
+    }
+    
+    .form-group {
+        margin-bottom: 1.5rem;
+    }
+    
+    .form-control {
+        display: block;
+        width: 100%;
+        padding: 0.5rem;
+        font-size: 1rem;
+        border: 1px solid #d1d5db;
+        border-radius: 0.25rem;
+    }
+    
+    label {
+        display: block;
+        margin-bottom: 0.5rem;
+        font-weight: 500;
+    }
+    
+    .form-text {
+        display: block;
+        margin-top: 0.25rem;
+        font-size: 0.875rem;
+        color: #64748b;
+    }
+    
+    .form-buttons {
+        display: flex;
+        gap: 1rem;
+        margin-top: 2rem;
+    }
+    
+    .file-metadata {
+        margin-top: 2rem;
+        padding: 1rem;
+        background-color: #f1f5f9;
+        border-radius: 0.5rem;
+    }
+    
+    .file-metadata h3 {
+        margin-top: 0;
+        font-size: 1.1rem;
+        color: #334155;
+    }
+    
+    .file-metadata p {
+        margin: 0.5rem 0;
+    }
+    
+    .info-note {
+        display: flex;
+        align-items: flex-start;
+        margin-top: 1rem;
+        padding: 0.75rem;
+        background-color: #e0f2fe;
+        border-radius: 0.25rem;
+    }
+    
+    .info-note .icon {
+        margin-right: 0.5rem;
+    }
+</style>
+{% endblock %} 
\ No newline at end of file
diff --git a/cmmc_tracker/config.py b/cmmc_tracker/config.py
index e4ead93..6186a72 100644
--- a/cmmc_tracker/config.py
+++ b/cmmc_tracker/config.py
@@ -52,6 +52,16 @@ class Config:
     # Flask-APScheduler settings
     SCHEDULER_API_ENABLED = False
     SCHEDULER_TIMEZONE = "UTC"
+    
+    # File upload settings
+    UPLOAD_FOLDER = os.environ.get('UPLOAD_FOLDER', os.path.join(os.getcwd(), 'uploads'))
+    MAX_CONTENT_LENGTH = int(os.environ.get('MAX_CONTENT_LENGTH', 16 * 1024 * 1024))  # 16MB default
+    ALLOWED_EXTENSIONS = {'pdf', 'png', 'jpg', 'jpeg', 'gif', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'csv'}
+    EVIDENCE_STATUS = {
+        'CURRENT': 'Current',
+        'EXPIRED': 'Expired',
+        'PENDING_REVIEW': 'Pending Review'
+    }
 
 class DevelopmentConfig(Config):
     """Development configuration."""
diff --git a/cmmc_tracker/uploads/evidence/AC.1.001/29d8a48f701f495ba20075347cdb687a_cmmc_controls_export_20250320.csv b/cmmc_tracker/uploads/evidence/AC.1.001/29d8a48f701f495ba20075347cdb687a_cmmc_controls_export_20250320.csv
new file mode 100644
index 0000000..8de5407
--- /dev/null
+++ b/cmmc_tracker/uploads/evidence/AC.1.001/29d8a48f701f495ba20075347cdb687a_cmmc_controls_export_20250320.csv
@@ -0,0 +1,111 @@
+Control ID,Control Name,Control Description,NIST Mapping,Review Frequency,Last Review Date,Next Review Date
+AC.1.001,"Limit information system access to authorized users, processes acting on behalf of authorized users, or devices (including other information systems).",Control who has access to your systems and what they can do.,3.1.1,Annual,2025-02-18,2026-02-18
+AC.1.002,Limit information system access to the types of transactions and functions that authorized users are permitted to execute.,Restrict user actions to only those necessary for their job.,3.1.2,Annual,2025-02-18,2026-02-18
+AC.1.003,Verify and control/limit connections to and use of external information systems.,Manage connections to systems outside your control.,3.1.3,Annual,2025-02-18,2026-02-18
+AC.2.001,Separate duties of individuals to reduce the risk of malevolent activity without collusion.,Divide critical tasks among different people to prevent fraud or misuse.,3.1.4,Annual,2025-02-18,2026-02-18
+AC.2.002,"Employ the principle of least privilege, including for specific security functions and privileged accounts.",Grant users and processes only the necessary privileges to do their jobs.,3.1.5,Annual,2025-02-18,2026-02-18
+AC.2.003,Use non-privileged accounts or roles when accessing nonsecurity functions.,Don’t use powerful accounts for everyday tasks to limit potential damage.,3.1.6,Annual,2025-02-18,2026-02-18
+AC.2.004,Prevent non-privileged users from executing privileged functions and capture the execution of such functions in audit logs.,Regular users should not be able to do administrator tasks.,3.1.7,Annual,2025-02-18,2026-02-18
+AC.2.005,Limit unsuccessful logon attempts.,Protect against attackers repeatedly trying to guess passwords.,3.1.8,Annual,2025-02-18,2026-02-18
+AC.2.006,Provide privacy and security notices consistent with applicable CUI rules.,Inform users of the rules and restrictions for using systems with CUI.,3.1.9,Annual,2025-02-18,2026-02-18
+AC.2.007,Use session lock with pattern-hiding displays to prevent access and viewing of data after a period of inactivity.,Quickly lock your screen to prevent unauthorized access.,3.1.10,Annual,2025-02-18,2026-02-18
+AC.2.008,Terminate (automatically) a user session after a defined condition.,Log users off automatically after a certain condition (e.g. inactivity).,3.1.11,Annual,2025-02-18,2026-02-18
+AC.2.009,Control remote access sessions.,Keep an eye on who is connecting to your network remotely.,3.1.12,Annual,2025-02-18,2026-02-18
+AC.2.010,Employ cryptographic mechanisms to protect the confidentiality of remote access sessions.,Use encryption to protect remote access connections.,3.1.13,Annual,2025-02-18,2026-02-18
+AC.2.011,Route remote access via managed access control points.,Control remote access through a limited number of points.,3.1.14,Annual,2025-02-18,2026-02-18
+AC.2.012,Authorize remote execution of privileged commands and remote access to security-relevant information.,Control the use of powerful commands and sensitive information remotely.,3.1.15,Annual,2025-02-18,2026-02-18
+AC.2.013,Authorize wireless access prior to allowing such connections.,Control the use of wireless networks and devices.,3.1.16,Annual,2025-02-18,2026-02-18
+AC.2.014,Protect wireless access using authentication and encryption.,Secure wireless connections with strong passwords and encryption.,3.1.17,Annual,2025-02-18,2026-02-18
+AC.2.015,Control connection of mobile devices.,Manage the use of mobile devices like phones and tablets.,3.1.18,Annual,2025-02-18,2026-02-18
+AC.2.016,Encrypt CUI on mobile devices and mobile computing platforms.,Protect CUI on mobile devices with encryption.,3.1.19,Annual,2025-02-18,2026-02-18
+AC.2.017,Verify and control/limit connections to and use of external systems.,Manage connections between your network and external systems.,3.1.20,Annual,2025-02-18,2026-02-18
+AC.2.018,Limit use of portable storage devices on external systems.,Control the use of portable storage devices like USB drives.,3.1.21,Annual,,
+AC.2.019,Control CUI posted or processed on publicly accessible systems.,Safeguard CUI on public systems.,3.1.22,Annual,,
+AT.1.001,"Ensure that managers, systems administrators, and users of organizational systems are made aware of the security risks associated with their activities and of the applicable policies, standards, and procedures related to the security of those systems.",Train staff on security awareness and their roles.,3.2.1,Annual,,
+AT.2.001,Ensure that personnel are trained to carry out their assigned information security-related duties and responsibilities.,Provide role-based training to staff.,3.2.2,Annual,,
+AT.3.001,Provide security awareness training on recognizing and reporting potential indicators of insider threat.,Train staff on insider threat awareness.,3.2.3,Annual,,
+AU.1.001,"Create and retain system audit logs and records to the extent needed to enable the monitoring, analysis, investigation, and reporting of unlawful or unauthorized system activity.",Create and keep audit logs.,3.3.1,Annual,,
+AU.2.001,Ensure that the actions of individual system users can be uniquely traced to those users so they can be held accountable for their actions.,Trace user actions for accountability.,3.3.2,Annual,,
+AU.3.001,Review and update logged events.,Regularly check and update what events are being logged.,3.3.3,Annual,,
+AU.3.002,Alert in the event of an audit logging process failure.,Set up alerts for audit log failures.,3.3.4,Annual,,
+AU.3.003,"Correlate audit record review, analysis, and reporting processes for investigation and response to indications of unlawful, unauthorized, suspicious, or unusual activity.",Analyze audit records for signs of suspicious activity.,3.3.5,Annual,,
+AU.3.004,Provide audit record reduction and report generation to support on-demand analysis and reporting.,Make audit records easier to analyze and report on.,3.3.6,Annual,,
+AU.3.005,Provide a system capability that compares and synchronizes internal system clocks with an authoritative source to generate time stamps for audit records.,Synchronize system clocks with an accurate time source.,3.3.7,Annual,,
+AU.3.006,"Protect audit information and audit logging tools from unauthorized access, modification, and deletion.",Secure audit logs and tools.,3.3.8,Annual,,
+AU.3.007,Limit management of audit logging functionality to a subset of privileged users.,Restrict access to audit log management functions.,3.3.9,Annual,,
+CA.1.001,Assess security controls.,Regularly assess security controls to ensure they are effective.,3.12.1,Annual,,
+CA.2.001,Develop and implement a plan of action.,Create and implement plans to fix security issues.,3.12.2,Annual,,
+CA.3.001,Monitor security controls.,Continuously monitor security controls.,3.12.3,Annual,,
+CA.4.001,Develop and update a system security plan.,Create and maintain a system security plan.,3.12.4,Annual,,
+CM.1.001,"Establish and maintain baseline configurations and inventories of organizational systems (including hardware, software, firmware, and documentation) throughout the respective system development life cycles.",Establish and maintain secure configurations.,3.4.1,Annual,,
+CM.1.002,Establish and enforce security configuration settings for information technology products employed in organizational systems.,Set and enforce secure configurations for IT products.,3.4.2,Annual,,
+CM.2.001,"Track, review, approve or disapprove, and log changes to organizational systems.",Manage changes to systems.,3.4.3,Annual,,
+CM.2.002,Analyze the security impact of changes prior to implementation.,Review changes for security impacts.,3.4.4,Annual,,
+CM.2.003,"Define, document, approve, and enforce physical and logical access restrictions associated with changes to organizational systems.",Control access to systems during changes.,3.4.5,Annual,,
+CM.2.004,Employ the principle of least functionality by configuring organizational systems to provide only essential capabilities.,Use the principle of least functionality.,3.4.6,Annual,,
+CM.2.005,"Restrict, disable, or prevent the use of nonessential programs, functions, ports, protocols, and services.",Limit unnecessary programs and services.,3.4.7,Annual,2024-04-04,2025-04-04
+CM.2.006,"Apply deny-by-exception (blacklisting) policy to prevent the use of unauthorized software or deny-all, permit-by-exception (whitelisting) policy to allow the execution of authorized software.",Use blacklisting or whitelisting to control software execution.,3.4.8,Annual,2024-04-04,2025-04-04
+CM.2.007,Control and monitor user-installed software.,Manage user-installed software.,3.4.9,Annual,2024-04-04,2025-04-04
+IA.1.001,"Identify system users, processes acting on behalf of users, and devices.","Assign unique IDs to users, processes, and devices.",3.5.1,Annual,2024-04-04,2025-04-04
+IA.1.002,"Authenticate (or verify) the identities of those users, processes, or devices, as a prerequisite to allowing access to organizational systems.",Verify identities before granting access.,3.5.2,Annual,2024-04-04,2025-04-04
+IA.1.003,Use multifactor authentication for local and network access to privileged accounts and for network access to non-privileged accounts.,Use multiple authentication factors.,3.5.3,Annual,,
+IA.1.004,Employ replay-resistant authentication mechanisms for network access to privileged and non-privileged accounts.,Use authentication methods that resist replay attacks.,3.5.4,Annual,,
+IA.1.005,Prevent reuse of identifiers for a defined period.,Don't reuse user IDs for a certain time.,3.5.5,Annual,,
+IA.2.006,Identifier Handling,Disable inactive user IDs.,3.5.6,Annual,,
+IA.2.007,Employ strong password composition.,Use strong passwords.,3.5.7,Annual,,
+IA.2.008,Prevent password reuse.,Don't reuse old passwords.,3.5.8,Annual,2024-02-14,2025-02-13
+IA.2.009,Use one-time passwords.,Use passwords that are valid for only one login session or a short period of time.,3.5.9,Annual,2024-02-14,2025-02-13
+IA.2.010,"Protect (i.e., encrypt) stored passwords.",Store passwords securely.,3.5.10,Annual,2024-02-14,2025-02-13
+IA.2.011,"Mask (i.e., obscure) authentication information.",Hide passwords and other authentication information.,3.5.11,Annual,,
+IR.1.001,Create an incident response plan.,Develop a plan for responding to security incidents.,3.6.1,Annual,,
+IR.2.001,Report incidents.,Report security incidents to the appropriate people.,3.6.2,Annual,,
+IR.3.001,Test incident response plan.,Regularly test your incident response plan.,3.6.3,Annual,,
+MA.1.001,Perform maintenance.,Regularly maintain your systems.,3.7.1,Annual,,
+MA.2.001,Control maintenance tools.,Manage the tools used for maintenance.,3.7.2,Annual,,
+MA.2.002,Sanitize media.,Clean or destroy media before reusing or discarding it.,3.7.3,Annual,,
+MA.2.003,Inspect media.,Check media for malicious code before using it.,3.7.4,Annual,,
+MA.2.004,Use multi-factor authentication for remote maintenance.,Use strong authentication for remote maintenance sessions.,3.7.5,Annual,,
+MA.2.005,Supervise maintenance personnel.,Supervise maintenance activities.,3.7.6,Annual,,
+MP.1.001,Protect CUI.,Protect the confidentiality of CUI.,3.8.1,Annual,,
+MP.2.001,Limit CUI access.,Limit access to CUI to authorized users.,3.8.2,Annual,,
+MP.2.002,Sanitize or destroy CUI media.,Clean or destroy media containing CUI before disposal or reuse.,3.8.3,Annual,,
+MP.3.001,Mark CUI media.,Mark media containing CUI with appropriate labels.,3.8.4,Annual,,
+MP.4.001,Control CUI media.,Control access to media containing CUI.,3.8.5,Annual,,
+MP.5.001,Encrypt CUI.,Encrypt CUI on portable storage devices.,3.8.6,Annual,,
+MP.6.001,Control removable media.,Control the use of removable media.,3.8.7,Annual,,
+MP.7.001,Prohibit shared media.,Do not allow the use of portable storage devices that have no identifiable owner.,3.8.8,Annual,,
+MP.8.001,Protect backups.,Protect the confidentiality of CUI backups.,3.8.9,Annual,,
+PE.1.001,Limit physical access.,"Limit physical access to organizational systems, equipment, and operating environments to authorized individuals.",3.10.1,Annual,,
+PE.2.001,Monitor physical access.,Monitor physical access to facilities and infrastructure.,3.10.2,Annual,,
+PE.2.002,Escort visitors.,Escort visitors and monitor their activity.,3.10.3,Annual,,
+PE.2.003,Maintain physical access logs.,Keep records of physical access.,3.10.4,Annual,,
+PE.2.004,Manage physical access devices.,Control and manage physical access devices.,3.10.5,Annual,,
+PE.2.005,Enforce safeguarding measures.,Enforce safeguards for CUI at alternate work sites.,3.10.6,Annual,,
+PS.1.001,Screen personnel.,Screen individuals before allowing them access to CUI.,3.9.1,Annual,,
+PS.2.001,Protect CUI during personnel actions.,Protect CUI when employees are terminated or transferred.,3.9.2,Annual,,
+RA.1.001,Conduct risk assessments.,"Regularly assess risk to organizational operations, assets, and individuals.",3.11.1,Annual,,
+RA.2.001,Scan for vulnerabilities.,Regularly scan for vulnerabilities in systems and applications.,3.11.2,Annual,,
+RA.3.001,Remediate vulnerabilities.,Fix vulnerabilities based on risk assessments.,3.11.3,Annual,,
+SC.1.001,Protect CUI.,Protect the confidentiality of CUI.,3.13.1,Annual,,
+SC.2.001,Employ security engineering.,Use secure design principles when building and updating systems.,3.13.2,Annual,,
+SC.3.001,Separate user functionality.,Separate user functions from system management functions.,3.13.3,Annual,,
+SC.3.002,Prevent information transfer.,Prevent unauthorized information transfer via shared system resources.,3.13.4,Annual,,
+SC.3.003,Implement subnetworks.,Use separate subnetworks for publicly accessible systems.,3.13.5,Annual,,
+SC.3.004,Deny network communications traffic.,Block network traffic by default and allow only authorized traffic.,3.13.6,Annual,,
+SC.3.005,Prevent split tunneling.,Prevent remote devices from connecting to both internal and external networks simultaneously.,3.13.7,Annual,,
+SC.3.006,Encrypt CUI.,Encrypt CUI during transmission.,3.13.8,Annual,,
+SC.3.007,Terminate network connections.,End network connections after a period of inactivity.,3.13.9,Annual,,
+SC.3.008,Establish cryptographic keys.,Establish and manage cryptographic keys.,3.13.10,Annual,,
+SC.3.009,Use FIPS-validated cryptography.,Use FIPS-validated cryptography to protect CUI.,3.13.11,Annual,,
+SC.3.010,Control collaborative devices.,Control and monitor the use of collaborative computing devices.,3.13.12,Annual,,
+SC.3.011,Control mobile code.,Control and monitor the use of mobile code.,3.13.13,Annual,,
+SC.3.012,Control VoIP.,Control and monitor the use of Voice over Internet Protocol (VoIP) technologies.,3.13.14,Annual,,
+SC.3.013,Protect communications sessions.,Protect the authenticity of communications sessions.,3.13.15,Annual,,
+SC.3.014,Protect CUI.,Protect the confidentiality of CUI at rest.,3.13.16,Annual,,
+SI.1.001,Correct system flaws.,"Identify, report, and correct system flaws.",3.14.1,Annual,,
+SI.1.002,Identify malicious code.,Identify malicious code.,3.14.2,Annual,,
+SI.1.003,Quarantine malicious code.,Isolate malicious code.,3.14.3,Annual,,
+SI.1.004,Remove malicious code.,Remove malicious code.,3.14.4,Annual,,
+SI.1.005,Report malicious code.,Report malicious code.,3.14.5,Annual,,
+SI.1.006,Update malicious code protection mechanisms.,Update malicious code protection mechanisms.,3.14.6,Annual,,
+SI.1.007,Monitor for malicious code.,Monitor for malicious code.,3.14.7,Annual,,
diff --git a/cmmc_tracker/uploads/evidence/AC.1.001/2a4c2e7d48a74df99482785eb8c35488_cmmc_controls_export_20250320.csv b/cmmc_tracker/uploads/evidence/AC.1.001/2a4c2e7d48a74df99482785eb8c35488_cmmc_controls_export_20250320.csv
new file mode 100644
index 0000000..8de5407
--- /dev/null
+++ b/cmmc_tracker/uploads/evidence/AC.1.001/2a4c2e7d48a74df99482785eb8c35488_cmmc_controls_export_20250320.csv
@@ -0,0 +1,111 @@
+Control ID,Control Name,Control Description,NIST Mapping,Review Frequency,Last Review Date,Next Review Date
+AC.1.001,"Limit information system access to authorized users, processes acting on behalf of authorized users, or devices (including other information systems).",Control who has access to your systems and what they can do.,3.1.1,Annual,2025-02-18,2026-02-18
+AC.1.002,Limit information system access to the types of transactions and functions that authorized users are permitted to execute.,Restrict user actions to only those necessary for their job.,3.1.2,Annual,2025-02-18,2026-02-18
+AC.1.003,Verify and control/limit connections to and use of external information systems.,Manage connections to systems outside your control.,3.1.3,Annual,2025-02-18,2026-02-18
+AC.2.001,Separate duties of individuals to reduce the risk of malevolent activity without collusion.,Divide critical tasks among different people to prevent fraud or misuse.,3.1.4,Annual,2025-02-18,2026-02-18
+AC.2.002,"Employ the principle of least privilege, including for specific security functions and privileged accounts.",Grant users and processes only the necessary privileges to do their jobs.,3.1.5,Annual,2025-02-18,2026-02-18
+AC.2.003,Use non-privileged accounts or roles when accessing nonsecurity functions.,Don’t use powerful accounts for everyday tasks to limit potential damage.,3.1.6,Annual,2025-02-18,2026-02-18
+AC.2.004,Prevent non-privileged users from executing privileged functions and capture the execution of such functions in audit logs.,Regular users should not be able to do administrator tasks.,3.1.7,Annual,2025-02-18,2026-02-18
+AC.2.005,Limit unsuccessful logon attempts.,Protect against attackers repeatedly trying to guess passwords.,3.1.8,Annual,2025-02-18,2026-02-18
+AC.2.006,Provide privacy and security notices consistent with applicable CUI rules.,Inform users of the rules and restrictions for using systems with CUI.,3.1.9,Annual,2025-02-18,2026-02-18
+AC.2.007,Use session lock with pattern-hiding displays to prevent access and viewing of data after a period of inactivity.,Quickly lock your screen to prevent unauthorized access.,3.1.10,Annual,2025-02-18,2026-02-18
+AC.2.008,Terminate (automatically) a user session after a defined condition.,Log users off automatically after a certain condition (e.g. inactivity).,3.1.11,Annual,2025-02-18,2026-02-18
+AC.2.009,Control remote access sessions.,Keep an eye on who is connecting to your network remotely.,3.1.12,Annual,2025-02-18,2026-02-18
+AC.2.010,Employ cryptographic mechanisms to protect the confidentiality of remote access sessions.,Use encryption to protect remote access connections.,3.1.13,Annual,2025-02-18,2026-02-18
+AC.2.011,Route remote access via managed access control points.,Control remote access through a limited number of points.,3.1.14,Annual,2025-02-18,2026-02-18
+AC.2.012,Authorize remote execution of privileged commands and remote access to security-relevant information.,Control the use of powerful commands and sensitive information remotely.,3.1.15,Annual,2025-02-18,2026-02-18
+AC.2.013,Authorize wireless access prior to allowing such connections.,Control the use of wireless networks and devices.,3.1.16,Annual,2025-02-18,2026-02-18
+AC.2.014,Protect wireless access using authentication and encryption.,Secure wireless connections with strong passwords and encryption.,3.1.17,Annual,2025-02-18,2026-02-18
+AC.2.015,Control connection of mobile devices.,Manage the use of mobile devices like phones and tablets.,3.1.18,Annual,2025-02-18,2026-02-18
+AC.2.016,Encrypt CUI on mobile devices and mobile computing platforms.,Protect CUI on mobile devices with encryption.,3.1.19,Annual,2025-02-18,2026-02-18
+AC.2.017,Verify and control/limit connections to and use of external systems.,Manage connections between your network and external systems.,3.1.20,Annual,2025-02-18,2026-02-18
+AC.2.018,Limit use of portable storage devices on external systems.,Control the use of portable storage devices like USB drives.,3.1.21,Annual,,
+AC.2.019,Control CUI posted or processed on publicly accessible systems.,Safeguard CUI on public systems.,3.1.22,Annual,,
+AT.1.001,"Ensure that managers, systems administrators, and users of organizational systems are made aware of the security risks associated with their activities and of the applicable policies, standards, and procedures related to the security of those systems.",Train staff on security awareness and their roles.,3.2.1,Annual,,
+AT.2.001,Ensure that personnel are trained to carry out their assigned information security-related duties and responsibilities.,Provide role-based training to staff.,3.2.2,Annual,,
+AT.3.001,Provide security awareness training on recognizing and reporting potential indicators of insider threat.,Train staff on insider threat awareness.,3.2.3,Annual,,
+AU.1.001,"Create and retain system audit logs and records to the extent needed to enable the monitoring, analysis, investigation, and reporting of unlawful or unauthorized system activity.",Create and keep audit logs.,3.3.1,Annual,,
+AU.2.001,Ensure that the actions of individual system users can be uniquely traced to those users so they can be held accountable for their actions.,Trace user actions for accountability.,3.3.2,Annual,,
+AU.3.001,Review and update logged events.,Regularly check and update what events are being logged.,3.3.3,Annual,,
+AU.3.002,Alert in the event of an audit logging process failure.,Set up alerts for audit log failures.,3.3.4,Annual,,
+AU.3.003,"Correlate audit record review, analysis, and reporting processes for investigation and response to indications of unlawful, unauthorized, suspicious, or unusual activity.",Analyze audit records for signs of suspicious activity.,3.3.5,Annual,,
+AU.3.004,Provide audit record reduction and report generation to support on-demand analysis and reporting.,Make audit records easier to analyze and report on.,3.3.6,Annual,,
+AU.3.005,Provide a system capability that compares and synchronizes internal system clocks with an authoritative source to generate time stamps for audit records.,Synchronize system clocks with an accurate time source.,3.3.7,Annual,,
+AU.3.006,"Protect audit information and audit logging tools from unauthorized access, modification, and deletion.",Secure audit logs and tools.,3.3.8,Annual,,
+AU.3.007,Limit management of audit logging functionality to a subset of privileged users.,Restrict access to audit log management functions.,3.3.9,Annual,,
+CA.1.001,Assess security controls.,Regularly assess security controls to ensure they are effective.,3.12.1,Annual,,
+CA.2.001,Develop and implement a plan of action.,Create and implement plans to fix security issues.,3.12.2,Annual,,
+CA.3.001,Monitor security controls.,Continuously monitor security controls.,3.12.3,Annual,,
+CA.4.001,Develop and update a system security plan.,Create and maintain a system security plan.,3.12.4,Annual,,
+CM.1.001,"Establish and maintain baseline configurations and inventories of organizational systems (including hardware, software, firmware, and documentation) throughout the respective system development life cycles.",Establish and maintain secure configurations.,3.4.1,Annual,,
+CM.1.002,Establish and enforce security configuration settings for information technology products employed in organizational systems.,Set and enforce secure configurations for IT products.,3.4.2,Annual,,
+CM.2.001,"Track, review, approve or disapprove, and log changes to organizational systems.",Manage changes to systems.,3.4.3,Annual,,
+CM.2.002,Analyze the security impact of changes prior to implementation.,Review changes for security impacts.,3.4.4,Annual,,
+CM.2.003,"Define, document, approve, and enforce physical and logical access restrictions associated with changes to organizational systems.",Control access to systems during changes.,3.4.5,Annual,,
+CM.2.004,Employ the principle of least functionality by configuring organizational systems to provide only essential capabilities.,Use the principle of least functionality.,3.4.6,Annual,,
+CM.2.005,"Restrict, disable, or prevent the use of nonessential programs, functions, ports, protocols, and services.",Limit unnecessary programs and services.,3.4.7,Annual,2024-04-04,2025-04-04
+CM.2.006,"Apply deny-by-exception (blacklisting) policy to prevent the use of unauthorized software or deny-all, permit-by-exception (whitelisting) policy to allow the execution of authorized software.",Use blacklisting or whitelisting to control software execution.,3.4.8,Annual,2024-04-04,2025-04-04
+CM.2.007,Control and monitor user-installed software.,Manage user-installed software.,3.4.9,Annual,2024-04-04,2025-04-04
+IA.1.001,"Identify system users, processes acting on behalf of users, and devices.","Assign unique IDs to users, processes, and devices.",3.5.1,Annual,2024-04-04,2025-04-04
+IA.1.002,"Authenticate (or verify) the identities of those users, processes, or devices, as a prerequisite to allowing access to organizational systems.",Verify identities before granting access.,3.5.2,Annual,2024-04-04,2025-04-04
+IA.1.003,Use multifactor authentication for local and network access to privileged accounts and for network access to non-privileged accounts.,Use multiple authentication factors.,3.5.3,Annual,,
+IA.1.004,Employ replay-resistant authentication mechanisms for network access to privileged and non-privileged accounts.,Use authentication methods that resist replay attacks.,3.5.4,Annual,,
+IA.1.005,Prevent reuse of identifiers for a defined period.,Don't reuse user IDs for a certain time.,3.5.5,Annual,,
+IA.2.006,Identifier Handling,Disable inactive user IDs.,3.5.6,Annual,,
+IA.2.007,Employ strong password composition.,Use strong passwords.,3.5.7,Annual,,
+IA.2.008,Prevent password reuse.,Don't reuse old passwords.,3.5.8,Annual,2024-02-14,2025-02-13
+IA.2.009,Use one-time passwords.,Use passwords that are valid for only one login session or a short period of time.,3.5.9,Annual,2024-02-14,2025-02-13
+IA.2.010,"Protect (i.e., encrypt) stored passwords.",Store passwords securely.,3.5.10,Annual,2024-02-14,2025-02-13
+IA.2.011,"Mask (i.e., obscure) authentication information.",Hide passwords and other authentication information.,3.5.11,Annual,,
+IR.1.001,Create an incident response plan.,Develop a plan for responding to security incidents.,3.6.1,Annual,,
+IR.2.001,Report incidents.,Report security incidents to the appropriate people.,3.6.2,Annual,,
+IR.3.001,Test incident response plan.,Regularly test your incident response plan.,3.6.3,Annual,,
+MA.1.001,Perform maintenance.,Regularly maintain your systems.,3.7.1,Annual,,
+MA.2.001,Control maintenance tools.,Manage the tools used for maintenance.,3.7.2,Annual,,
+MA.2.002,Sanitize media.,Clean or destroy media before reusing or discarding it.,3.7.3,Annual,,
+MA.2.003,Inspect media.,Check media for malicious code before using it.,3.7.4,Annual,,
+MA.2.004,Use multi-factor authentication for remote maintenance.,Use strong authentication for remote maintenance sessions.,3.7.5,Annual,,
+MA.2.005,Supervise maintenance personnel.,Supervise maintenance activities.,3.7.6,Annual,,
+MP.1.001,Protect CUI.,Protect the confidentiality of CUI.,3.8.1,Annual,,
+MP.2.001,Limit CUI access.,Limit access to CUI to authorized users.,3.8.2,Annual,,
+MP.2.002,Sanitize or destroy CUI media.,Clean or destroy media containing CUI before disposal or reuse.,3.8.3,Annual,,
+MP.3.001,Mark CUI media.,Mark media containing CUI with appropriate labels.,3.8.4,Annual,,
+MP.4.001,Control CUI media.,Control access to media containing CUI.,3.8.5,Annual,,
+MP.5.001,Encrypt CUI.,Encrypt CUI on portable storage devices.,3.8.6,Annual,,
+MP.6.001,Control removable media.,Control the use of removable media.,3.8.7,Annual,,
+MP.7.001,Prohibit shared media.,Do not allow the use of portable storage devices that have no identifiable owner.,3.8.8,Annual,,
+MP.8.001,Protect backups.,Protect the confidentiality of CUI backups.,3.8.9,Annual,,
+PE.1.001,Limit physical access.,"Limit physical access to organizational systems, equipment, and operating environments to authorized individuals.",3.10.1,Annual,,
+PE.2.001,Monitor physical access.,Monitor physical access to facilities and infrastructure.,3.10.2,Annual,,
+PE.2.002,Escort visitors.,Escort visitors and monitor their activity.,3.10.3,Annual,,
+PE.2.003,Maintain physical access logs.,Keep records of physical access.,3.10.4,Annual,,
+PE.2.004,Manage physical access devices.,Control and manage physical access devices.,3.10.5,Annual,,
+PE.2.005,Enforce safeguarding measures.,Enforce safeguards for CUI at alternate work sites.,3.10.6,Annual,,
+PS.1.001,Screen personnel.,Screen individuals before allowing them access to CUI.,3.9.1,Annual,,
+PS.2.001,Protect CUI during personnel actions.,Protect CUI when employees are terminated or transferred.,3.9.2,Annual,,
+RA.1.001,Conduct risk assessments.,"Regularly assess risk to organizational operations, assets, and individuals.",3.11.1,Annual,,
+RA.2.001,Scan for vulnerabilities.,Regularly scan for vulnerabilities in systems and applications.,3.11.2,Annual,,
+RA.3.001,Remediate vulnerabilities.,Fix vulnerabilities based on risk assessments.,3.11.3,Annual,,
+SC.1.001,Protect CUI.,Protect the confidentiality of CUI.,3.13.1,Annual,,
+SC.2.001,Employ security engineering.,Use secure design principles when building and updating systems.,3.13.2,Annual,,
+SC.3.001,Separate user functionality.,Separate user functions from system management functions.,3.13.3,Annual,,
+SC.3.002,Prevent information transfer.,Prevent unauthorized information transfer via shared system resources.,3.13.4,Annual,,
+SC.3.003,Implement subnetworks.,Use separate subnetworks for publicly accessible systems.,3.13.5,Annual,,
+SC.3.004,Deny network communications traffic.,Block network traffic by default and allow only authorized traffic.,3.13.6,Annual,,
+SC.3.005,Prevent split tunneling.,Prevent remote devices from connecting to both internal and external networks simultaneously.,3.13.7,Annual,,
+SC.3.006,Encrypt CUI.,Encrypt CUI during transmission.,3.13.8,Annual,,
+SC.3.007,Terminate network connections.,End network connections after a period of inactivity.,3.13.9,Annual,,
+SC.3.008,Establish cryptographic keys.,Establish and manage cryptographic keys.,3.13.10,Annual,,
+SC.3.009,Use FIPS-validated cryptography.,Use FIPS-validated cryptography to protect CUI.,3.13.11,Annual,,
+SC.3.010,Control collaborative devices.,Control and monitor the use of collaborative computing devices.,3.13.12,Annual,,
+SC.3.011,Control mobile code.,Control and monitor the use of mobile code.,3.13.13,Annual,,
+SC.3.012,Control VoIP.,Control and monitor the use of Voice over Internet Protocol (VoIP) technologies.,3.13.14,Annual,,
+SC.3.013,Protect communications sessions.,Protect the authenticity of communications sessions.,3.13.15,Annual,,
+SC.3.014,Protect CUI.,Protect the confidentiality of CUI at rest.,3.13.16,Annual,,
+SI.1.001,Correct system flaws.,"Identify, report, and correct system flaws.",3.14.1,Annual,,
+SI.1.002,Identify malicious code.,Identify malicious code.,3.14.2,Annual,,
+SI.1.003,Quarantine malicious code.,Isolate malicious code.,3.14.3,Annual,,
+SI.1.004,Remove malicious code.,Remove malicious code.,3.14.4,Annual,,
+SI.1.005,Report malicious code.,Report malicious code.,3.14.5,Annual,,
+SI.1.006,Update malicious code protection mechanisms.,Update malicious code protection mechanisms.,3.14.6,Annual,,
+SI.1.007,Monitor for malicious code.,Monitor for malicious code.,3.14.7,Annual,,
diff --git a/cookies.txt b/cookies.txt
index 0541dda..140ebd9 100644
--- a/cookies.txt
+++ b/cookies.txt
@@ -2,4 +2,4 @@
 # https://curl.se/docs/http-cookies.html
 # This file was generated by libcurl! Edit at your own risk.
 
-#HttpOnly_localhost	FALSE	/	FALSE	0	session	.eJwNxUEKhTAMBcCrPLIWD-ApXLgTkUijDdRWkiqKePf_ZzMvzWtij-LUjS-h_qPAeROjhoYoWIvteMoJP5dda5UAdWi-OGlAMUR2yH2oSWjRJ2EXVHvAG2tuafqm7wcLCCOk.Z9sELg.ePfQ-nnBbax18KA1wuMqYNMU4Y8
+#HttpOnly_localhost	FALSE	/	FALSE	0	session	eyJfZnJlc2giOmZhbHNlLCJjc3JmX3Rva2VuIjoiMTNlNGYyMmRiOTg0MjYyZjVjYzgzN2YyMGQ3ZDI1YWQwOWU4OGRjNSJ9.Z9huLg.7PgH6Y4FPFHGNH7yol84bKMLHTo
diff --git a/db/init.sql b/db/01_init.sql
similarity index 100%
rename from db/init.sql
rename to db/01_init.sql
diff --git a/db/02_migration_tracking.sql b/db/02_migration_tracking.sql
new file mode 100644
index 0000000..0d88b12
--- /dev/null
+++ b/db/02_migration_tracking.sql
@@ -0,0 +1,22 @@
+-- Migration tracking table
+-- This table keeps track of which migrations have been applied
+
+-- Check if migration_history table exists
+DO $$ 
+BEGIN
+    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'migration_history') THEN
+        CREATE TABLE migration_history (
+            id SERIAL PRIMARY KEY,
+            migration_name VARCHAR(255) NOT NULL UNIQUE,
+            applied_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
+            applied_by VARCHAR(255)
+        );
+        
+        CREATE INDEX idx_migration_name ON migration_history(migration_name);
+        CREATE INDEX idx_applied_at ON migration_history(applied_at);
+        
+        RAISE NOTICE 'Created migration_history table';
+    ELSE
+        RAISE NOTICE 'Migration_history table already exists';
+    END IF;
+END $$; 
\ No newline at end of file
diff --git a/db/03_evidence_migration.sql b/db/03_evidence_migration.sql
new file mode 100644
index 0000000..eb1f2a9
--- /dev/null
+++ b/db/03_evidence_migration.sql
@@ -0,0 +1,32 @@
+-- Evidence table migration
+-- Creates the table for storing evidence records
+
+-- Check if evidence table exists
+DO $$ 
+BEGIN
+    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'evidence') THEN
+        CREATE TABLE evidence (
+            evidenceid SERIAL PRIMARY KEY,
+            controlid TEXT NOT NULL,
+            title TEXT NOT NULL,
+            description TEXT,
+            filepath TEXT,
+            filetype TEXT,
+            filesize BIGINT,
+            uploadedby TEXT NOT NULL,
+            uploaddate TEXT NOT NULL,
+            expirationdate TEXT,
+            status TEXT NOT NULL DEFAULT 'Current',
+            FOREIGN KEY (controlid) REFERENCES controls(controlid) ON DELETE CASCADE
+        );
+        
+        CREATE INDEX idx_evidence_controlid ON evidence(controlid);
+        CREATE INDEX idx_evidence_uploaddate ON evidence(uploaddate);
+        CREATE INDEX idx_evidence_expirationdate ON evidence(expirationdate);
+        CREATE INDEX idx_evidence_status ON evidence(status);
+        
+        RAISE NOTICE 'Created evidence table';
+    ELSE
+        RAISE NOTICE 'Evidence table already exists';
+    END IF;
+END $$; 
\ No newline at end of file
diff --git a/db/README.md b/db/README.md
new file mode 100644
index 0000000..e59dde4
--- /dev/null
+++ b/db/README.md
@@ -0,0 +1,81 @@
+# Database Migrations
+
+This directory contains SQL migration scripts for the CMMC Compliance Tracker database.
+
+## Migration Structure
+
+- `01_init.sql` - Initial database schema creation script
+- `02_migration_tracking.sql` - Creates the table used to track applied migrations
+- `03_evidence_migration.sql` - Adds the evidence table for storing compliance evidence files
+
+## File Naming Convention
+
+Migration files follow a numbered sequence format to ensure they are executed in the correct order:
+
+1. `01_init.sql` - Always runs first to set up base tables
+2. `02_migration_tracking.sql` - Creates the migration tracking infrastructure
+3. `03_evidence_migration.sql` and onwards - Feature-specific migrations
+
+This numbering is essential when running in Docker, as PostgreSQL executes scripts in the `docker-entrypoint-initdb.d` directory in alphabetical order.
+
+## Applying Migrations
+
+Migrations can be applied using the `apply_migration.py` script:
+
+```bash
+# Apply all migrations
+python apply_migration.py
+
+# Apply a specific migration
+python apply_migration.py db/evidence_migration.sql
+```
+
+When running in Docker:
+
+```bash
+# Apply all migrations
+docker compose exec web python apply_migration.py
+
+# Apply a specific migration
+docker compose exec web python apply_migration.py db/evidence_migration.sql
+```
+
+## Migration Tracking
+
+The system automatically tracks applied migrations in the `migration_history` table. This ensures that migrations are only applied once, even if the migration script is run multiple times.
+
+## Creating New Migrations
+
+To create a new migration:
+
+1. Create a new SQL file in this directory with a descriptive name (e.g., `add_email_notifications.sql`)
+2. Include proper error handling and idempotent operations in your SQL script
+3. Use the following pattern for table creation:
+
+```sql
+-- Check if table exists
+DO $$ 
+BEGIN
+    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'your_table_name') THEN
+        CREATE TABLE your_table_name (
+            -- column definitions
+        );
+        
+        -- indexes, constraints, etc.
+        
+        RAISE NOTICE 'Created your_table_name table';
+    ELSE
+        RAISE NOTICE 'your_table_name table already exists';
+    END IF;
+END $$;
+```
+
+This ensures that migrations can be safely re-run without errors.
+
+## Best Practices
+
+1. Always make migrations idempotent (can be run multiple times without error)
+2. Include proper error handling in SQL scripts
+3. Use descriptive names for migration files
+4. Document migrations in this README file
+5. Test migrations in a development environment before applying to production 
\ No newline at end of file
diff --git a/dev_notes.md b/dev_notes.md
index ee75b6c..a55451d 100644
--- a/dev_notes.md
+++ b/dev_notes.md
@@ -22,6 +22,7 @@ This document provides comprehensive technical documentation of the CMMC Complia
 12. [Database Initialization](#database-initialization)
 13. [Common Issues and Troubleshooting](#common-issues-and-troubleshooting)
 14. [Testing](#testing)
+15. [Database Migrations](#database-migrations)
 
 ## Architecture Overview
 
@@ -709,6 +710,86 @@ The user interface has been simplified to avoid dependencies on complex JavaScri
 
 These UI simplifications make the application more robust, especially in containerized environments where browser compatibility and JavaScript execution might be less predictable.
 
+## Database Migrations
+
+### Overview
+
+The CMMC Compliance Tracker application now supports database migrations for schema evolution. This allows for adding new tables, columns, and other database objects in a controlled manner.
+
+### Migration System
+
+The migration system consists of:
+
+1. **SQL Migration Files** - Located in the `/db` directory with descriptive names (e.g., `evidence_migration.sql`)
+2. **Migration Tracking Table** - A table in the database that tracks which migrations have been applied
+3. **Migration Application Script** - The `apply_migration.py` script that handles applying migrations
+
+### How to Apply Migrations
+
+For local development:
+```
+python apply_migration.py
+```
+
+In Docker environment:
+```
+docker compose exec web python apply_migration.py
+```
+
+### How to Create New Migrations
+
+1. Create a new SQL file in the `/db` directory with a descriptive name
+2. Use the numbered file format to ensure correct execution order (e.g., `04_add_custom_field.sql`)
+3. Use the template pattern for idempotent operations:
+
+```sql
+-- Check if the feature exists before creating it
+DO $$ 
+BEGIN
+    IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'table_name') THEN
+        -- Create the table/column/etc.
+        CREATE TABLE table_name (...);
+        
+        RAISE NOTICE 'Created table_name';
+    ELSE
+        RAISE NOTICE 'table_name already exists';
+    END IF;
+END $$;
+```
+
+4. Add proper error handling and logging in the SQL script
+5. Test the migration thoroughly before committing
+
+### Docker Initialization
+
+When running in Docker, the PostgreSQL container executes SQL files in the `docker-entrypoint-initdb.d` directory in alphabetical order. This is why we use a numbered prefix format (`01_`, `02_`, etc.) for migration files to ensure they run in the correct sequence.
+
+The sequence is important because:
+1. Base tables must be created first
+2. The migration tracking table should be created next
+3. Feature-specific migrations can then be applied
+
+If migrations fail during Docker initialization, check the database logs with `docker compose logs db`.
+
+### Verification
+
+After applying migrations, you can verify that they were applied correctly:
+
+```
+python check_evidence_table.py
+```
+
+This will check if the evidence table exists and output its structure and indexes.
+
+### Best Practices
+
+1. Migrations should be forward-only (no rollbacks)
+2. Make migrations idempotent so they can be safely re-run
+3. Add proper documentation in the SQL file header about what the migration does
+4. Keep migrations focused on a single concern (e.g., adding one table or feature)
+5. Use transactions where appropriate
+6. Avoid direct data manipulation in migrations when possible
+
 ---
 
 This documentation is intended to be a living document. As the application evolves, please keep it updated to reflect the current state of the codebase. 
diff --git a/start.sh b/start.sh
index 87f541a..4627824 100644
--- a/start.sh
+++ b/start.sh
@@ -10,6 +10,9 @@ done
 echo "Checking if database needs to be initialized..."
 python /app/seed_db.py
 
+echo "Applying any pending database migrations..."
+python /app/apply_migration.py
+
 echo "Starting the application..."
 cd /app/cmmc_tracker
 exec gunicorn --bind 0.0.0.0:80 --workers 4 run:app 
\ No newline at end of file
